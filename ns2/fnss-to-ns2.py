#!/usr/bin/env python
#
# Fast Network Simulation Setup (FNSS), ns-2 adapter
#
# Copyright (c) 2012 Lorenzo Saino
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
import argparse
import sys, re


try:
    from fnss.util import time_units, capacity_units
    from fnss.topologies.topology import read_topology
except ImportError:
    raise ImportError("The FNSS core package is needed to run this script.")


__all__ = ['convert_xml_to_ns2',
           'convert_object_to_ns2',
           'validate_ns2_stacks']

class __Templite(object):
    #
    # Templite+
    # A light-weight, fully functional, general purpose templating engine
    #
    # Copyright (c) 2009 joonis new media
    # Author: Thimo Kraemer <thimo.kraemer@joonis.de>
    #
    # Based on Templite by Tomer Filiba
    # http://code.activestate.com/recipes/496702/
    #
    # This program is free software; you can redistribute it and/or modify
    # it under the terms of the GNU General Public License as published by
    # the Free Software Foundation; either version 2 of the License, or
    # (at your option) any later version.
    #       
    # This program is distributed in the hope that it will be useful,
    # but WITHOUT ANY WARRANTY; without even the implied warranty of
    # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    # GNU General Public License for more details.
    #       
    # You should have received a copy of the GNU General Public License
    # along with this program; if not, write to the Free Software
    # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
    # MA 02110-1301, USA.
    #
    auto_emit = re.compile('(^[\'\"])|(^[a-zA-Z0-9_\[\]\'\"]+$)')
    
    def __init__(self, template, start='${', end='}$'):
        if len(start) != 2 or len(end) != 2:
            raise ValueError('each delimiter must be two characters long')
        delimiter = re.compile('%s(.*?)%s' % (re.escape(start), re.escape(end)), re.DOTALL)
        offset = 0
        tokens = []
        for i, part in enumerate(delimiter.split(template)):
            part = part.replace('\\'.join(list(start)), start)
            part = part.replace('\\'.join(list(end)), end)
            if i % 2 == 0:
                if not part: continue
                part = part.replace('\\', '\\\\').replace('"', '\\"')
                part = '\t' * offset + 'emit("""%s""")' % part
            else:
                part = part.rstrip()
                if not part: continue
                if part.lstrip().startswith(':'):
                    if not offset:
                        raise SyntaxError('no block statement to terminate: ${%s}$' % part)
                    offset -= 1
                    part = part.lstrip()[1:]
                    if not part.endswith(':'): continue
                elif self.auto_emit.match(part.lstrip()):
                    part = 'emit(%s)' % part.lstrip()
                lines = part.splitlines()
                margin = min(len(l) - len(l.lstrip()) for l in lines if l.strip())
                part = '\n'.join('\t' * offset + l[margin:] for l in lines)
                if part.endswith(':'):
                    offset += 1
            tokens.append(part)
        if offset:
            raise SyntaxError('%i block statement(s) not terminated' % offset)
        self.__code = compile('\n'.join(tokens), '<templite %r>' % template[:20], 'exec')

    def render(self, __namespace=None, **kw):
        """
        renders the template according to the given namespace. 
        __namespace - a dictionary serving as a namespace for evaluation
        **kw - keyword arguments which are added to the namespace
        """
        namespace = {}
        if __namespace: namespace.update(__namespace)
        if kw: namespace.update(kw)
        namespace['emit'] = self.write
        
        __stdout = sys.stdout
        sys.stdout = self
        self.__output = []
        eval(self.__code, namespace)
        sys.stdout = __stdout
        return ''.join(self.__output)
    
    def write(self, *args):
        for a in args:
            self.__output.append(str(a))



# Template text rendered by the template engine
__template = r"""# Code generated by Fast Network Simulator Setup (FNSS)
@{
from fnss.util import delay_units, capacity_units
from fnss.netconfig.nodeconfig import *
capacity_norm = capacity_units[G.graph['capacity_unit']] / 1000000.0 # Convert it in Mb
if set_delays: delay_norm = delay_units[G.graph['delay_unit']] # Convert it in ms
}@
#Create a simulator object
set ns [new Simulator]

#Create nodes
@{
for v in G.nodes():
    emit("set n%s [$ns node]\n" % str(v))
}@
# Create all links
set qtype DropTail
@{ 
for u, v in G.edges():
    delay = "0" if not set_delays else str(G.edge[u][v]['delay']*delay_norm)
    emit("$ns duplex-link $n%s $n%s %sMb %sms $qtype\n" % (str(u), str(v), str(G.edge[u][v]['capacity']*capacity_norm), delay))

if set_buffers:
    emit("\n# Set queue sizes\n")
    for u, v in G.edges():
        emit("$ns queue-limit $n%s $n%s %s\n" % (str(u), str(v), G.edge[u][v]['buffer']))

if deploy_stacks:
    emit("\n# Deploy applications and agents\n")
    for v in G.nodes():
        if stack(G, v) is None:
            continue
            
        stack_name = G.node[v]['stack'][0]
        stack_class = G.node[v]['stack'][1]['class']
        emit("set %s [new %s]\n" % (stack_name, stack_class))
        for prop_name, prop_val in G.node[v]['stack'][1].items():
            if prop_name is 'class':
                continue
            emit("$%s set %s %s\n" % (str(stack_name), str(prop_name), str(prop_val)))
        emit("$ns attach-agent $n%s $%s\n" % (v, stack_name))
        emit("\n")
        
        for application_name in applications(G, v):
            application_class = G.node[v]['application'][application_name]['class']
            emit("set %s [new %s]\n" % (application_name, application_class))
            for prop_name, prop_val in G.node[v]['application'][application_name].items():
                if prop_name == 'class':
                    continue
                emit("$%s set %s %s\n" % (str(application_name), str(prop_name), str(prop_val)))
            emit("$%s attach-agent $%s\n" % (application_name, stack_name))
}@
"""

def __print_log(level, message):
    green = '\033[92m'
    yellow = '\033[93m'
    red = '\033[91m'
    end = '\033[0m'
    if level is 'error':
        message = "".join([red, '[ERROR] ', message, end])
    elif level is 'warning':
        message = "".join([yellow, '[WARNING] ', message, end])
    elif level is 'info':
        message = "".join([green, '[INFO] ', message, end])
    print(message)


def validate_ns2_stacks(G):
    """
    Validate whether the stacks of a topology are valid for ns-2 deployment
    """
    for v in G.nodes():
        if G.node[v].has_key('application'):
            for name in G.node[v]['application']:
                if not G.node[v]['application'][name].has_key('class'):
                    return False
            if not G.node[v].has_key('stack'):
                return False;
        elif G.node[v].has_key('stack'):
            stack_props in G.node[v]['stack'][1]
            if not stack_props.has_key('class'):
                return False
    return True
            
    


def convert_objects_to_ns2(G, ns2_file, deploy_stacks=True, log=False):
    """
    Converts topology and schedule objects into an ns-2 Tcl script
    """
    set_buffers = True
    set_delays = True
    
    if not G.graph.has_key('capacity_unit'):
        if log: 
            __print_log('error', 'Missing capacity unit attribute in the topology. '\
                          'Set capacities and try again')
            return
        else:
            raise ValueError('The given topology does not have capacity data')
    if not capacity_units.has_key(G.graph['capacity_unit']):
        if log: 
            __print_log('error', 'The capacity unit attribute of the topology (%s) '\
                          'cannot be recognized.' % G.graph['capacity_unit'])
            return
        else:
            raise ValueError('The given topology does not have a valid capacity unit')
    if not G.graph.has_key('buffer_unit') :
        if log: __print_log('warning', 'Missing buffer size unit attribute in the topology.'\
                          ' Output file will be generated without buffer assignments')
        set_buffers = False
    if not G.graph['buffer_unit'] == 'packets':
        if log: __print_log('warning', 'The buffer size unit of the topology is %s. '\
                          'The only supported unit is packets. Output file will be '\
                          'generated without buffer assignments' % G.graph['buffer_unit'])
        set_buffers = False
    if not G.graph.has_key('delay_unit') or not delay_units.has_key(G.graph['delay_unit']):
        if log: __print_log('warning', 'Missing or invalid delay unit attribute in the topology.'\
                              ' Output file will be generated with all link delays set to 0')
        set_delays = False
    if deploy_stacks and not validate_ns2_stacks(G):
        if log: __print_log('warning', 'Some application stacks cannot be parsed correctly. '\
                          'Read the documentation to learn how to properly configure stacks.' \
                          ' Output file will be generated without stack assignments')
        deploy_stacks = False   
    template = __Templite(__template, start='@{', end='}@')
    out_file = open(ns2_file, "w")
    out_file.write(template.render({'G': G, 'deploy_stacks': deploy_stacks, 'set_delays': set_delays, 'set_buffers': set_buffers}, x=8))
    out_file.close()
    if log: __print_log('info', 'Output file created successfully')


def convert_xml_to_ns2(ns2_file, topology_file, deploy_stacks=True, log=False):
    """
    Converts topology and schedule XML files into an ns-2 Tcl script
    """
    G = read_topology(topology_file)
    convert_objects_to_ns2(G, ns2_file, deploy_stacks, log)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()   
    parser.add_argument("-t", "--topology", help='The topology XML file', required=True)
    parser.add_argument("ns2file", help="The file where the ns-2 Tcl script is written")
    args = parser.parse_args()
    convert_xml_to_ns2(args.ns2file, args.topology, deploy_stacks=True, log=True)

